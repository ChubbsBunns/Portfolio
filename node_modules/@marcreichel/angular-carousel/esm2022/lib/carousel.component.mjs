import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { CarouselSlideDirective } from "./slide.directive";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class CarouselComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.bullets = true;
        this.infinite = false;
        this.auto = false;
        this.duration = 5000;
        this.page = new EventEmitter();
        this.previous = new EventEmitter();
        this.next = new EventEmitter();
        this.slides = new QueryList();
        this.currentSlide = 0;
        this.interval = 0;
    }
    ngAfterContentChecked() {
        this.cdr.detectChanges();
        this.currentSlide = Math.max(Math.min(this.currentSlide, this.slides.length - 1), 0);
    }
    ngOnChanges(changes) {
        if (changes.auto) {
            if (changes.auto.currentValue) {
                this.startInterval();
            }
            else {
                this.stopInterval();
            }
        }
    }
    ngOnDestroy() {
        this.stopInterval();
    }
    previousSlide($event) {
        if ($event) {
            $event.preventDefault();
            $event.stopPropagation();
        }
        if (this.currentSlide <= 0) {
            this.currentSlide = this.slides.length - 1;
        }
        else {
            this.currentSlide--;
        }
        this.emitPrevious();
        this.restartInterval();
    }
    nextSlide($event) {
        if ($event) {
            $event.preventDefault();
            $event.stopPropagation();
        }
        if (this.currentSlide >= this.slides.length - 1) {
            this.currentSlide = 0;
        }
        else {
            this.currentSlide++;
        }
        this.emitNext();
        this.restartInterval();
    }
    goToSlide(slide, $event) {
        if ($event) {
            $event.preventDefault();
            $event.stopPropagation();
        }
        const index = slide - 1;
        if (index < 0 || index >= this.slides.length) {
            return;
        }
        if (index === this.currentSlide) {
            return;
        }
        this.currentSlide = index;
        this.emitPage();
        this.restartInterval();
    }
    startInterval() {
        if (!this.auto) {
            return;
        }
        this.interval = setInterval(() => {
            this.nextSlide();
        }, Math.max(this.duration, 500));
    }
    stopInterval() {
        if (!this.auto) {
            return;
        }
        clearInterval(this.interval);
    }
    emitPrevious() {
        this.previous.emit(this.currentSlide + 1);
        this.emitPage();
    }
    emitNext() {
        this.next.emit(this.currentSlide + 1);
        this.emitPage();
    }
    emitPage() {
        this.page.emit(this.currentSlide + 1);
    }
    restartInterval() {
        this.stopInterval();
        this.startInterval();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.7", ngImport: i0, type: CarouselComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.7", type: CarouselComponent, selector: "angular-carousel", inputs: { bullets: "bullets", infinite: "infinite", auto: "auto", duration: "duration" }, outputs: { page: "page", previous: "previous", next: "next" }, queries: [{ propertyName: "slides", predicate: CarouselSlideDirective }], usesOnChanges: true, ngImport: i0, template: "<div class=\"carousel__container\">\n  <div class=\"carousel__slider\">\n    <div *ngIf=\"infinite || currentSlide > 0\" class=\"carousel__previous\">\n      <button (click)=\"previousSlide($event)\">\n        <svg viewBox=\"0 0 20 20\">\n          <polyline points=\"12 2, 7 10, 12 18\"\n                    stroke=\"currentColor\"\n                    stroke-width=\"2\"\n                    stroke-linecap=\"round\"\n                    fill=\"transparent\"\n                    stroke-linejoin=\"round\"></polyline>\n        </svg>\n      </button>\n    </div>\n    <ol [style.left.%]=\"currentSlide * -100\" class=\"carousel__slides\" (mouseenter)=\"stopInterval()\"\n        (mouseleave)=\"startInterval()\">\n      <li *ngFor=\"let slide of slides; let index = index\" [ngClass]=\"{'carousel__slide--active':index===currentSlide}\"\n          class=\"carousel__slide\">\n        <ng-container [ngTemplateOutlet]=\"slide.template\"></ng-container>\n      </li>\n    </ol>\n    <div *ngIf=\"infinite || currentSlide < slides.length - 1\" class=\"carousel__next\">\n      <button (click)=\"nextSlide($event)\">\n        <svg viewBox=\"0 0 20 20\">\n          <polyline points=\"8 2, 13 10, 8 18\"\n                    stroke=\"currentColor\"\n                    stroke-width=\"2\"\n                    stroke-linecap=\"round\"\n                    fill=\"transparent\"\n                    stroke-linejoin=\"round\"></polyline>\n        </svg>\n      </button>\n    </div>\n  </div>\n  <ng-container *ngIf=\"bullets === undefined || bullets\">\n    <ol class=\"carousel__bullets\">\n      <li *ngFor=\"let slide of slides; let index = index\">\n        <button (click)=\"goToSlide(index + 1, $event)\"\n                [ngClass]=\"{'carousel__bullet--active':index===currentSlide}\"\n                class=\"carousel__bullet\">\n          <span class=\"sr-only\">{{ index + 1 }}</span>\n        </button>\n      </li>\n    </ol>\n  </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.7", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'angular-carousel', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"carousel__container\">\n  <div class=\"carousel__slider\">\n    <div *ngIf=\"infinite || currentSlide > 0\" class=\"carousel__previous\">\n      <button (click)=\"previousSlide($event)\">\n        <svg viewBox=\"0 0 20 20\">\n          <polyline points=\"12 2, 7 10, 12 18\"\n                    stroke=\"currentColor\"\n                    stroke-width=\"2\"\n                    stroke-linecap=\"round\"\n                    fill=\"transparent\"\n                    stroke-linejoin=\"round\"></polyline>\n        </svg>\n      </button>\n    </div>\n    <ol [style.left.%]=\"currentSlide * -100\" class=\"carousel__slides\" (mouseenter)=\"stopInterval()\"\n        (mouseleave)=\"startInterval()\">\n      <li *ngFor=\"let slide of slides; let index = index\" [ngClass]=\"{'carousel__slide--active':index===currentSlide}\"\n          class=\"carousel__slide\">\n        <ng-container [ngTemplateOutlet]=\"slide.template\"></ng-container>\n      </li>\n    </ol>\n    <div *ngIf=\"infinite || currentSlide < slides.length - 1\" class=\"carousel__next\">\n      <button (click)=\"nextSlide($event)\">\n        <svg viewBox=\"0 0 20 20\">\n          <polyline points=\"8 2, 13 10, 8 18\"\n                    stroke=\"currentColor\"\n                    stroke-width=\"2\"\n                    stroke-linecap=\"round\"\n                    fill=\"transparent\"\n                    stroke-linejoin=\"round\"></polyline>\n        </svg>\n      </button>\n    </div>\n  </div>\n  <ng-container *ngIf=\"bullets === undefined || bullets\">\n    <ol class=\"carousel__bullets\">\n      <li *ngFor=\"let slide of slides; let index = index\">\n        <button (click)=\"goToSlide(index + 1, $event)\"\n                [ngClass]=\"{'carousel__bullet--active':index===currentSlide}\"\n                class=\"carousel__bullet\">\n          <span class=\"sr-only\">{{ index + 1 }}</span>\n        </button>\n      </li>\n    </ol>\n  </ng-container>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { bullets: [{
                type: Input
            }], infinite: [{
                type: Input
            }], auto: [{
                type: Input
            }], duration: [{
                type: Input
            }], page: [{
                type: Output
            }], previous: [{
                type: Output
            }], next: [{
                type: Output
            }], slides: [{
                type: ContentChildren,
                args: [CarouselSlideDirective]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1jYXJvdXNlbC9zcmMvbGliL2Nhcm91c2VsLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItY2Fyb3VzZWwvc3JjL2xpYi9jYXJvdXNlbC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLG1CQUFtQixDQUFDOzs7QUFPekQsTUFBTSxPQUFPLGlCQUFpQjtJQWdCNUIsWUFBb0IsR0FBc0I7UUFBdEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFmMUIsWUFBTyxHQUFZLElBQUksQ0FBQztRQUN4QixhQUFRLEdBQVksS0FBSyxDQUFDO1FBQzFCLFNBQUksR0FBWSxLQUFLLENBQUM7UUFDdEIsYUFBUSxHQUFXLElBQUksQ0FBQztRQUV2QixTQUFJLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7UUFDeEQsYUFBUSxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO1FBQzVELFNBQUksR0FBeUIsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUV6QixXQUFNLEdBQXNDLElBQUksU0FBUyxFQUEwQixDQUFDO1FBRTdILGlCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBRXhCLGFBQVEsR0FBVyxDQUFDLENBQUM7SUFFaUIsQ0FBQztJQUV4QyxxQkFBcUI7UUFDMUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENB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R0FBRyxDQUFDLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEIsQ0FBQztJQUVPLFFBQVE7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBRU8sUUFBUTtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVPLGVBQWU7UUFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDOzhHQXpIVSxpQkFBaUI7a0dBQWpCLGlCQUFpQix3T0FVWCxzQkFBc0Isa0RDaEN6Qyw0NkRBOENBOzsyRkR4QmEsaUJBQWlCO2tCQUw3QixTQUFTOytCQUNFLGtCQUFrQixtQkFFWCx1QkFBdUIsQ0FBQyxNQUFNO3dHQUcvQixPQUFPO3NCQUF0QixLQUFLO2dCQUNVLFFBQVE7c0JBQXZCLEtBQUs7Z0JBQ1UsSUFBSTtzQkFBbkIsS0FBSztnQkFDVSxRQUFRO3NCQUF2QixLQUFLO2dCQUVXLElBQUk7c0JBQXBCLE1BQU07Z0JBQ1UsUUFBUTtzQkFBeEIsTUFBTTtnQkFDVSxJQUFJO3NCQUFwQixNQUFNO2dCQUV5QyxNQUFNO3NCQUFyRCxlQUFlO3VCQUFDLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudENoZWNrZWQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtDYXJvdXNlbFNsaWRlRGlyZWN0aXZlfSBmcm9tIFwiLi9zbGlkZS5kaXJlY3RpdmVcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYW5ndWxhci1jYXJvdXNlbCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9jYXJvdXNlbC5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBDYXJvdXNlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgcHVibGljIGJ1bGxldHM6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBwdWJsaWMgaW5maW5pdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgcHVibGljIGF1dG86IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgcHVibGljIGR1cmF0aW9uOiBudW1iZXIgPSA1MDAwO1xuXG4gIEBPdXRwdXQoKSBwdWJsaWMgcGFnZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgQE91dHB1dCgpIHB1YmxpYyBwcmV2aW91czogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgQE91dHB1dCgpIHB1YmxpYyBuZXh0OiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2Fyb3VzZWxTbGlkZURpcmVjdGl2ZSkgcHVibGljIHNsaWRlczogUXVlcnlMaXN0PENhcm91c2VsU2xpZGVEaXJlY3RpdmU+ID0gbmV3IFF1ZXJ5TGlzdDxDYXJvdXNlbFNsaWRlRGlyZWN0aXZlPigpO1xuXG4gIHB1YmxpYyBjdXJyZW50U2xpZGU6IG51bWJlciA9IDA7XG5cbiAgcHJpdmF0ZSBpbnRlcnZhbDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHsgfVxuXG4gIHB1YmxpYyBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIHRoaXMuY3VycmVudFNsaWRlID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5jdXJyZW50U2xpZGUsIHRoaXMuc2xpZGVzLmxlbmd0aCAtIDEpLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMuYXV0bykge1xuICAgICAgaWYgKGNoYW5nZXMuYXV0by5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGFydEludGVydmFsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3BJbnRlcnZhbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BJbnRlcnZhbCgpO1xuICB9XG5cbiAgcHVibGljIHByZXZpb3VzU2xpZGUoJGV2ZW50PzogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGlmICgkZXZlbnQpIHtcbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50U2xpZGUgPD0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50U2xpZGUgPSB0aGlzLnNsaWRlcy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZS0tO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdFByZXZpb3VzKCk7XG4gICAgdGhpcy5yZXN0YXJ0SW50ZXJ2YWwoKTtcbiAgfVxuXG4gIHB1YmxpYyBuZXh0U2xpZGUoJGV2ZW50PzogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGlmICgkZXZlbnQpIHtcbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50U2xpZGUgPj0gdGhpcy5zbGlkZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jdXJyZW50U2xpZGUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSsrO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdE5leHQoKTtcbiAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCgpO1xuICB9XG5cbiAgcHVibGljIGdvVG9TbGlkZShzbGlkZTogbnVtYmVyLCAkZXZlbnQ/OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgaWYgKCRldmVudCkge1xuICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBzbGlkZSAtIDE7XG5cbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2xpZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U2xpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IGluZGV4O1xuICAgIHRoaXMuZW1pdFBhZ2UoKTtcbiAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCgpO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0SW50ZXJ2YWwoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmF1dG8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubmV4dFNsaWRlKCk7XG4gICAgfSwgTWF0aC5tYXgodGhpcy5kdXJhdGlvbiwgNTAwKSk7XG4gIH1cblxuICBwdWJsaWMgc3RvcEludGVydmFsKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hdXRvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRQcmV2aW91cygpOiB2b2lkIHtcbiAgICB0aGlzLnByZXZpb3VzLmVtaXQodGhpcy5jdXJyZW50U2xpZGUgKyAxKTtcbiAgICB0aGlzLmVtaXRQYWdlKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXROZXh0KCk6IHZvaWQge1xuICAgIHRoaXMubmV4dC5lbWl0KHRoaXMuY3VycmVudFNsaWRlICsgMSk7XG4gICAgdGhpcy5lbWl0UGFnZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0UGFnZSgpOiB2b2lkIHtcbiAgICB0aGlzLnBhZ2UuZW1pdCh0aGlzLmN1cnJlbnRTbGlkZSArIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXN0YXJ0SW50ZXJ2YWwoKTogdm9pZCB7XG4gICAgdGhpcy5zdG9wSW50ZXJ2YWwoKTtcbiAgICB0aGlzLnN0YXJ0SW50ZXJ2YWwoKTtcbiAgfVxuXG59XG4iLCI8ZGl2IGNsYXNzPVwiY2Fyb3VzZWxfX2NvbnRhaW5lclwiPlxuICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWxfX3NsaWRlclwiPlxuICAgIDxkaXYgKm5nSWY9XCJpbmZpbml0ZSB8fCBjdXJyZW50U2xpZGUgPiAwXCIgY2xhc3M9XCJjYXJvdXNlbF9fcHJldmlvdXNcIj5cbiAgICAgIDxidXR0b24gKGNsaWNrKT1cInByZXZpb3VzU2xpZGUoJGV2ZW50KVwiPlxuICAgICAgICA8c3ZnIHZpZXdCb3g9XCIwIDAgMjAgMjBcIj5cbiAgICAgICAgICA8cG9seWxpbmUgcG9pbnRzPVwiMTIgMiwgNyAxMCwgMTIgMThcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PC9wb2x5bGluZT5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgICA8b2wgW3N0eWxlLmxlZnQuJV09XCJjdXJyZW50U2xpZGUgKiAtMTAwXCIgY2xhc3M9XCJjYXJvdXNlbF9fc2xpZGVzXCIgKG1vdXNlZW50ZXIpPVwic3RvcEludGVydmFsKClcIlxuICAgICAgICAobW91c2VsZWF2ZSk9XCJzdGFydEludGVydmFsKClcIj5cbiAgICAgIDxsaSAqbmdGb3I9XCJsZXQgc2xpZGUgb2Ygc2xpZGVzOyBsZXQgaW5kZXggPSBpbmRleFwiIFtuZ0NsYXNzXT1cInsnY2Fyb3VzZWxfX3NsaWRlLS1hY3RpdmUnOmluZGV4PT09Y3VycmVudFNsaWRlfVwiXG4gICAgICAgICAgY2xhc3M9XCJjYXJvdXNlbF9fc2xpZGVcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJzbGlkZS50ZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgPC9saT5cbiAgICA8L29sPlxuICAgIDxkaXYgKm5nSWY9XCJpbmZpbml0ZSB8fCBjdXJyZW50U2xpZGUgPCBzbGlkZXMubGVuZ3RoIC0gMVwiIGNsYXNzPVwiY2Fyb3VzZWxfX25leHRcIj5cbiAgICAgIDxidXR0b24gKGNsaWNrKT1cIm5leHRTbGlkZSgkZXZlbnQpXCI+XG4gICAgICAgIDxzdmcgdmlld0JveD1cIjAgMCAyMCAyMFwiPlxuICAgICAgICAgIDxwb2x5bGluZSBwb2ludHM9XCI4IDIsIDEzIDEwLCA4IDE4XCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjwvcG9seWxpbmU+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8bmctY29udGFpbmVyICpuZ0lmPVwiYnVsbGV0cyA9PT0gdW5kZWZpbmVkIHx8IGJ1bGxldHNcIj5cbiAgICA8b2wgY2xhc3M9XCJjYXJvdXNlbF9fYnVsbGV0c1wiPlxuICAgICAgPGxpICpuZ0Zvcj1cImxldCBzbGlkZSBvZiBzbGlkZXM7IGxldCBpbmRleCA9IGluZGV4XCI+XG4gICAgICAgIDxidXR0b24gKGNsaWNrKT1cImdvVG9TbGlkZShpbmRleCArIDEsICRldmVudClcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnY2Fyb3VzZWxfX2J1bGxldC0tYWN0aXZlJzppbmRleD09PWN1cnJlbnRTbGlkZX1cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiY2Fyb3VzZWxfX2J1bGxldFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiPnt7IGluZGV4ICsgMSB9fTwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2xpPlxuICAgIDwvb2w+XG4gIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG4iXX0=